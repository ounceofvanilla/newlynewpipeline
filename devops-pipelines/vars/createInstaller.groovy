def doPreStageProcessing(def prePostProcessing, Map pipelineParams) {
   prePostProcessing.preCreateInstaller(pipelineParams)
}

def doMainStageProcessing(Map pipelineParams) {
   switch(pipelineParams.CREATE_INSTALLER_CHOICE) {
      case 'debian':
         if (!isUnix()) {
            logger.logError(constants.INCOMPATIBLE_ENVIRONMENT_ERROR + ": Debian, Windows")
         }

         // Create directory for installer and move package description file
         dir("${pipelineParams.PACKAGE_NAME}/DEBIAN") {
            sh """
               mv "${env.WORKSPACE}/${pipelineParams.INSTALLER_CONFIG_FILE}" .
            """
         }
         
         //Retrieves an array of the artifacts found based on the pattern.
         def sourceArtifactArray = artifactManagement.getArtifactFilePaths(pipelineParams)
         //Copies each artifact in the debian package folder with the install path
         sourceArtifactArray.each { localFilePath ->
            // See if we need to append the local directory structure
            if (pipelineParams.ARTIFACT_REPLICATE_LOCAL_PATH_FLAG == "true") {
               // First trim off workspace from the front of the path
               def relativeFilePath = localFilePath - WORKSPACE
               // Make sure to convert forward slashes for possible Windows paths
               relativeFilePath = relativeFilePath.replaceAll("\\\\", "/")
               // Now just get the directory
               def relativeBaseDir = relativeFilePath.substring(0, relativeFilePath.lastIndexOf('/'))
               //Create the directory based on relativeBaseDir and copy the artifact from its original location into it.
               dir ("${pipelineParams.PACKAGE_NAME}${relativeBaseDir}"){
                  sh """
                     cp "${localFilePath}" .
                  """
               }
            }
            else {
               //If ARTIFACT_REPLICATE_LOCAL_PATH_FLAG is false then use the PACKAGE_INSTALL_PATH as the structure in the package.
               dir ("${pipelineParams.PACKAGE_NAME}/${pipelineParams.PACKAGE_INSTALL_PATH}"){
                  sh """
                     cp "${localFilePath}" .
                  """
               }
            }
         }

         sh """
            dpkg-deb --build "${pipelineParams.PACKAGE_NAME}"
         """

         break
      case 'cpack':
         // Use CPack to create both Installation and source packages.
         // The location of packages can be specified in configuration files.
         // The configuration files generated by CMake are placed at
         // the location specified by parameter PREBUILD_DIRECTORY. The custom
         // configuration files are placed at Jenkins job workspace root directory.

         // Parameter CPACK_INSTALL_CMAKE_PROJECTS is for the installation packages with the configuration files generated by CMake.
         def CPackProject = "-D CPACK_INSTALL_CMAKE_PROJECTS='${pipelineParams.PREBUILD_DIRECTORY};${pipelineParams.PREBUILD_DIRECTORY};${pipelineParams.PACKAGE_NAME?.toLowerCase()};;ALL;'"
         // Parameter CPACK_INSTALLED_DIRECTORIES is for source packages with the configuration files generated by CMake.
         def CPackDirectory = "-D CPACK_INSTALLED_DIRECTORIES='${pipelineParams.PREBUILD_DIRECTORY};.;'"
         // The type of CPack generator for the creation of installation and source packages
         def CPackGenerator = pipelineParams.CPACK_GENERATOR?.toLowerCase() == 'archive' ? "" : "-G ${pipelineParams.CPACK_GENERATOR?.toUpperCase()}"

         // Go to the location specified by parameter PREBUILD_DIRECTORY because CMake has been run there
         dir(pipelineParams.PREBUILD_DIRECTORY) {
            sh """
               if [ -e CPackConfig.cmake ] && [ '${pipelineParams.CPACK_WITH_CMAKE}' = 'true' ]
               then
                  cpack ${CPackGenerator} ${CPackProject} --config CPackConfig.cmake
               else
                  cpack ${CPackGenerator} --config '${pipelineParams.CMAKE_LISTS_PATH}'CustomCPackConfig.cmake
               fi
               if [ -e CPackSourceConfig.cmake ] && [ '${pipelineParams.CPACK_WITH_CMAKE}' = 'true' ]
               then
                  cpack ${CPackGenerator} ${CPackDirectory} --config CPackSourceConfig.cmake
               else
                  cpack ${CPackGenerator} --config '${pipelineParams.CMAKE_LISTS_PATH}'CustomCPackSourceConfig.cmake
               fi
            """
         }
         break
      default:
         logger.logError(constants.INVALID_TOOL_FOR_STAGE, pipelineParams.CREATE_INSTALLER_CHOICE, this.getClass().getSimpleName())
         break
   }
}

def doMainStageAnalysis(Map pipelineParams) {
   logger.logInfo("Analysis is not applicable for the installer creation stage.")
}

def doPostStageProcessing(def prePostProcessing, Map pipelineParams) {
   prePostProcessing.postCreateInstaller(pipelineParams)
}

def call(Map pipelineParams) { 
   doMainStageProcessing(pipelineParams)
}